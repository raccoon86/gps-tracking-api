<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>실시간 GPS 시뮬레이션 - 마라톤 대회</title>

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />

    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <!-- Custom CSS -->
    <style>
      body {
        font-family: "Noto Sans KR", sans-serif;
        background-color: #f8f9fa;
      }

      #map {
        height: 600px;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .control-panel {
        background: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      .leaderboard {
        background: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .user-marker {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 3px solid white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 12px;
        color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      .user-1 {
        background-color: #ff4444;
      }
      .user-2 {
        background-color: #44ff44;
      }
      .user-3 {
        background-color: #4444ff;
      }
      .user-4 {
        background-color: #ffaa44;
      }
      .user-5 {
        background-color: #aa44ff;
      }

      .status-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 5px;
      }

      .status-running {
        background-color: #28a745;
      }
      .status-stopped {
        background-color: #dc3545;
      }
      .status-paused {
        background-color: #ffc107;
      }

      .stats {
        font-size: 0.9em;
        color: #666;
      }

      .speed-control {
        margin: 10px 0;
      }

      .user-info {
        margin-bottom: 15px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 5px;
        border-left: 4px solid;
      }

      .user-info-1 {
        border-left-color: #ff4444;
      }
      .user-info-2 {
        border-left-color: #44ff44;
      }
      .user-info-3 {
        border-left-color: #4444ff;
      }
      .user-info-4 {
        border-left-color: #ffaa44;
      }
      .user-info-5 {
        border-left-color: #aa44ff;
      }

      .log-area {
        height: 200px;
        overflow-y: auto;
        background-color: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        font-family: monospace;
        font-size: 0.9em;
      }
    </style>
  </head>
  <body>
    <div class="container-fluid mt-3">
      <div class="row">
        <!-- 지도 영역 -->
        <div class="col-lg-8">
          <div class="control-panel">
            <h2 class="mb-3">🏃‍♂️ 실시간 GPS 시뮬레이션 - 마라톤 대회</h2>

            <!-- 컨트롤 버튼들 -->
            <div class="d-flex gap-2 mb-3">
              <button id="initBtn" class="btn btn-primary">
                시스템 초기화
              </button>
              <button id="startBtn" class="btn btn-success">
                시뮬레이션 시작
              </button>
              <button id="pauseBtn" class="btn btn-warning">일시정지</button>
              <button id="stopBtn" class="btn btn-danger">정지</button>
              <button id="resetBtn" class="btn btn-secondary">리셋</button>
              <button id="stopBatchBtn" class="btn btn-outline-danger">
                배치 테스트 중지
              </button>
              <button id="startPeriodicFakeBtn" class="btn btn-outline-primary">
                ⏱️ Fake GPS 주기적 전송 시작
              </button>
              <button id="stopPeriodicFakeBtn" class="btn btn-outline-danger">
                ⏹️ Fake GPS 전송 중지
              </button>
            </div>

            <!-- 개별 설정 버튼들 -->
            <div class="d-flex gap-2 mb-3">
              <button id="createEventBtn" class="btn btn-outline-primary">
                🏆 대회 생성
              </button>
              <button id="createCourseBtn" class="btn btn-outline-info">
                🛤️ 코스 생성
              </button>
              <button id="createUsersBtn" class="btn btn-outline-success">
                👥 유저 생성
              </button>
              <button id="checkStatusBtn" class="btn btn-outline-secondary">
                📊 상태 확인
              </button>
            </div>

            <!-- 새로운 GPS 테스트 버튼들 -->
            <div class="d-flex gap-2 mb-3">
              <button id="generateFakeBtn" class="btn btn-info">
                📱 Fake GPS 데이터 생성
              </button>
              <button id="batchTestBtn" class="btn btn-warning">
                🚀 배치 테스트 (유저1)
              </button>
              <button id="allUsersBatchBtn" class="btn btn-success">
                🏃‍♂️ 전체 유저 배치 테스트
              </button>
            </div>

            <!-- 시뮬레이션 설정 -->
            <div class="row">
              <div class="col-md-6">
                <label for="speedRange" class="form-label"
                  >시뮬레이션 속도</label
                >
                <input
                  type="range"
                  class="form-range"
                  id="speedRange"
                  min="1"
                  max="10"
                  value="3"
                />
                <span id="speedValue">3x</span>
              </div>
              <div class="col-md-6">
                <label for="errorRange" class="form-label">GPS 오차 범위</label>
                <input
                  type="range"
                  class="form-range"
                  id="errorRange"
                  min="5"
                  max="50"
                  value="15"
                />
                <span id="errorValue">15m</span>
              </div>
            </div>
          </div>

          <!-- 지도 -->
          <div id="map"></div>
        </div>

        <!-- 사이드바 -->
        <div class="col-lg-4">
          <!-- 실시간 순위 -->
          <div class="leaderboard mb-3">
            <h4 class="mb-3">🏆 실시간 순위</h4>
            <div id="leaderboard">
              <div class="text-center text-muted">
                시뮬레이션을 시작하면 순위가 표시됩니다.
              </div>
            </div>
          </div>

          <!-- 참가자 정보 -->
          <div class="leaderboard mb-3">
            <h4 class="mb-3">👥 참가자 현황</h4>
            <div id="participantInfo">
              <!-- 참가자 정보가 여기에 표시됩니다 -->
            </div>
          </div>

          <!-- 로그 -->
          <div class="leaderboard">
            <h5 class="mb-3">📊 시스템 로그</h5>
            <div id="logArea" class="log-area"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Main JavaScript -->
    <script>
      // 전역 변수
      let map;
      let gpxRoute;
      let userMarkers = {};
      let simulationRunning = false;
      let batchTestRunning = false;
      let simulationInterval;
      let currentPositions = {};
      let simulationSpeed = 3;
      let gpsErrorRange = 15;
      // 주기적 Fake GPS 전송 관련 변수
      let periodicFakeGpsInterval = null;
      let periodicFakeGpsData = null;

      // API 설정
      const API_BASE = "";
      const EVENT_ID = 1;
      const EVENT_DETAIL_ID = 100;

      // 테스트 유저 정보
      const TEST_USERS = [
        { userId: 1, name: "김러너", bibNumber: "A001", color: "#ff4444" },
        { userId: 2, name: "이스피드", bibNumber: "A002", color: "#44ff44" },
        { userId: 3, name: "박마라톤", bibNumber: "A003", color: "#4444ff" },
        { userId: 4, name: "최러닝", bibNumber: "A004", color: "#ffaa44" },
        { userId: 5, name: "정트랙", bibNumber: "A005", color: "#aa44ff" },
      ];

      // GPX 경로 데이터 (test_route.gpx 좌표들)
      const GPX_POINTS = [
        [37.5413553485092, 127.115719020367],
        [37.5390881874808, 127.114029228687],
        [37.5379482005428, 127.113452553749],
        [37.5353682776934, 127.11048334837],
        [37.5351258071487, 127.110266089439],
        [37.5344154064531, 127.109783291817],
        [37.5337836971563, 127.109482884407],
        [37.5320799696497, 127.108764052391],
        [37.5317162475003, 127.108696997166],
        [37.5315503385624, 127.108699679375],
        [37.5301273352067, 127.107908427715],
        [37.5301188268838, 127.107884287834],
        [37.5266260783458, 127.1042740345],
        [37.5258773070672, 127.104005813599],
        [37.5255709893779, 127.103651762009],
        [37.5252731793075, 127.102814912796],
        [37.5235713846696, 127.101398706436],
      ];

      // 초기화
      document.addEventListener("DOMContentLoaded", function () {
        initMap();
        initEventListeners();
        initParticipantInfo();
        log("시스템 준비 완료");
      });

      // 지도 초기화
      function initMap() {
        // 지도 생성 (서울 강남 지역)
        map = L.map("map").setView([37.5353682776934, 127.11048334837], 14);

        // 타일 레이어 추가
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "© OpenStreetMap contributors",
        }).addTo(map);

        // GPX 경로 표시
        gpxRoute = L.polyline(GPX_POINTS, {
          color: "#2563eb",
          weight: 5,
          opacity: 0.8,
        }).addTo(map);

        // 시작점과 끝점 마커
        L.marker(GPX_POINTS[0]).addTo(map).bindPopup("🏁 시작점").openPopup();

        L.marker(GPX_POINTS[GPX_POINTS.length - 1])
          .addTo(map)
          .bindPopup("🏁 도착점");

        // 지도 범위를 GPX 경로에 맞춤
        map.fitBounds(gpxRoute.getBounds(), { padding: [20, 20] });
      }

      // 이벤트 리스너 초기화
      function initEventListeners() {
        document
          .getElementById("initBtn")
          .addEventListener("click", initializeSystem);
        document
          .getElementById("startBtn")
          .addEventListener("click", startSimulation);
        document
          .getElementById("pauseBtn")
          .addEventListener("click", pauseSimulation);
        document
          .getElementById("stopBtn")
          .addEventListener("click", stopSimulation);
        document
          .getElementById("resetBtn")
          .addEventListener("click", resetSimulation);
        document
          .getElementById("stopBatchBtn")
          .addEventListener("click", stopBatchTest);

        // 개별 설정 버튼들
        document
          .getElementById("createEventBtn")
          .addEventListener("click", createEvent);
        document
          .getElementById("createCourseBtn")
          .addEventListener("click", createCourse);
        document
          .getElementById("createUsersBtn")
          .addEventListener("click", createUsers);
        document
          .getElementById("checkStatusBtn")
          .addEventListener("click", checkStatus);

        // 새로운 GPS 테스트 버튼들
        document
          .getElementById("generateFakeBtn")
          .addEventListener("click", generateFakeGpsData);
        document
          .getElementById("batchTestBtn")
          .addEventListener("click", () => batchTestSingleUser(1));
        document
          .getElementById("allUsersBatchBtn")
          .addEventListener("click", batchTestAllUsers);

        // 시뮬레이션 속도 조절
        document
          .getElementById("speedRange")
          .addEventListener("input", function (e) {
            simulationSpeed = parseInt(e.target.value);
            document.getElementById("speedValue").textContent =
              simulationSpeed + "x";
            log(`시뮬레이션 속도 변경: ${simulationSpeed}x`);
          });

        // GPS 오차 범위 조절
        document
          .getElementById("errorRange")
          .addEventListener("input", function (e) {
            gpsErrorRange = parseInt(e.target.value);
            document.getElementById("errorValue").textContent =
              gpsErrorRange + "m";
            log(`GPS 오차 범위 변경: ${gpsErrorRange}m`);
          });

        // 주기적 Fake GPS 전송 버튼 이벤트
        document
          .getElementById("startPeriodicFakeBtn")
          .addEventListener("click", startPeriodicFakeGpsSend);
        document
          .getElementById("stopPeriodicFakeBtn")
          .addEventListener("click", stopPeriodicFakeGpsSend);
      }

      // 참가자 정보 초기화
      function initParticipantInfo() {
        const container = document.getElementById("participantInfo");
        container.innerHTML = "";

        TEST_USERS.forEach((user) => {
          const userDiv = document.createElement("div");
          userDiv.className = `user-info user-info-${user.userId}`;
          userDiv.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <strong>${user.name}</strong> (${user.bibNumber})
                            <span class="status-indicator status-stopped" id="status-${user.userId}"></span>
                        </div>
                        <div class="stats" id="stats-${user.userId}">
                            준비 중
                        </div>
                    </div>
                    <div class="stats" id="location-${user.userId}">
                        위치: 대기 중
                    </div>
                `;
          container.appendChild(userDiv);
        });
      }

      // 시스템 초기화
      async function initializeSystem() {
        log("시스템 초기화 시작...");

        try {
          // 1. Event 생성
          log("1. 이벤트 생성 중...");
          const eventResponse = await fetch(
            `${API_BASE}/api/gpx/create-test-event?eventId=${EVENT_ID}&eventName=TestMarathon`,
            {
              method: "POST",
            }
          );

          if (eventResponse.ok) {
            log("✅ 이벤트 생성 완료");
          } else {
            log("⚠️ 이벤트 생성 실패 (이미 존재하거나 오류)");
          }

          // 2. EventDetail 생성
          log("2. 코스 생성 중...");
          const courseResponse = await fetch(
            `${API_BASE}/api/gpx/create-test-course?eventId=${EVENT_ID}&eventDetailId=${EVENT_DETAIL_ID}&courseName=TestCourse`,
            {
              method: "POST",
            }
          );

          if (courseResponse.ok) {
            log("✅ 코스 생성 완료");
          } else {
            log("⚠️ 코스 생성 실패 (이미 존재하거나 오류)");
          }

          // 3. GPX 파일 업로드
          log("3. GPX 파일 업로드 중...");
          // GPX 파일이 이미 업로드되어 있다고 가정
          log("✅ GPX 파일 업로드 완료 (이미 존재)");

          // 4. 테스트 유저 생성
          log("4. 테스트 유저 생성 중...");
          const usersResponse = await fetch(
            `${API_BASE}/api/gpx/create-test-users?eventId=${EVENT_ID}&eventDetailId=${EVENT_DETAIL_ID}`,
            {
              method: "POST",
            }
          );

          if (usersResponse.ok) {
            const usersData = await usersResponse.json();
            log("✅ 테스트 유저 5명 생성 완료");
            log(
              `   생성된 유저: ${usersData.users.map((u) => u.name).join(", ")}`
            );
          } else {
            log("❌ 테스트 유저 생성 실패");
          }

          // 5. 유저 마커 초기화
          initUserMarkers();

          log("🎉 시스템 초기화 완료! 시뮬레이션을 시작할 수 있습니다.");
        } catch (error) {
          log(`❌ 시스템 초기화 실패: ${error.message}`);
        }
      }

      // 유저 마커 초기화
      function initUserMarkers() {
        // 기존 마커 제거
        Object.values(userMarkers).forEach((marker) => {
          map.removeLayer(marker);
        });
        userMarkers = {};

        // 모든 유저를 시작점에 배치
        TEST_USERS.forEach((user) => {
          const startPoint = GPX_POINTS[0];
          currentPositions[user.userId] = {
            pointIndex: 0,
            progress: 0,
            lat: startPoint[0],
            lng: startPoint[1],
            lastUpdate: Date.now(),
          };

          // 커스텀 마커 생성
          const markerElement = L.divIcon({
            className: "custom-marker",
            html: `<div class="user-marker user-${user.userId}">${user.userId}</div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 15],
          });

          const marker = L.marker([startPoint[0], startPoint[1]], {
            icon: markerElement,
          })
            .addTo(map)
            .bindPopup(`${user.name} (${user.bibNumber})`);

          userMarkers[user.userId] = marker;

          updateUserStatus(user.userId, "stopped", "준비 완료");
        });
      }

      // 시뮬레이션 시작
      function startSimulation() {
        if (simulationRunning) {
          log("⚠️ 시뮬레이션이 이미 실행 중입니다.");
          return;
        }

        if (batchTestRunning) {
          log(
            "⚠️ 배치 테스트가 실행 중입니다. 먼저 배치 테스트를 완료해주세요."
          );
          return;
        }

        simulationRunning = true;
        log("🚀 실시간 시뮬레이션 시작");

        // 모든 유저 상태를 running으로 변경
        TEST_USERS.forEach((user) => {
          updateUserStatus(user.userId, "running", "진행 중");
        });

        // 시뮬레이션 루프 시작 (1초마다)
        simulationInterval = setInterval(() => {
          updateSimulation();
        }, 1000 / simulationSpeed);

        // 1분마다 위치 보정 API 호출
        setInterval(() => {
          if (simulationRunning) {
            sendLocationCorrection();
          }
        }, 600000); // 60초
      }

      // 시뮬레이션 업데이트
      function updateSimulation() {
        TEST_USERS.forEach((user) => {
          updateUserPosition(user.userId);
        });
        updateLeaderboard(); // 항상 호출
      }

      // 유저 위치 업데이트
      function updateUserPosition(userId) {
        const position = currentPositions[userId];
        if (!position) return;

        // 각 유저마다 다른 속도로 진행 (약간의 랜덤 요소 추가)
        const baseSpeed = 0.005 + userId * 0.001; // 유저별 다른 기본 속도
        const randomFactor = 0.5 + Math.random(); // 0.5 ~ 1.5 랜덤 속도
        const speed = baseSpeed * randomFactor;

        // 진행률 업데이트
        position.progress += speed;

        // 도착점에 도달했는지 체크
        if (
          position.pointIndex >= GPX_POINTS.length - 1 ||
          position.progress >= 1.0
        ) {
          // 도착점에 고정
          position.pointIndex = GPX_POINTS.length - 1;
          position.progress = 1.0;
          position.lat = GPX_POINTS[GPX_POINTS.length - 1][0];
          position.lng = GPX_POINTS[GPX_POINTS.length - 1][1];
          position.lastUpdate = Date.now();

          // 마커 위치 도착점에 고정
          if (userMarkers[userId]) {
            userMarkers[userId].setLatLng([position.lat, position.lng]);
          }

          updateUserStatus(userId, "stopped", "도착");
          updateLocationInfo(
            userId,
            position.lat,
            position.lng,
            2400,
            Math.floor(
              (Date.now() -
                (currentPositions[userId].startTime || Date.now())) /
                1000
            )
          );
          return;
        }

        // 다음 포인트로 이동할지 결정
        if (
          position.progress >= 1.0 &&
          position.pointIndex < GPX_POINTS.length - 1
        ) {
          position.pointIndex++;
          position.progress = 0;
        }

        // 현재 위치 계산 (두 포인트 간 보간, 항상 다음 포인트 방향)
        if (position.pointIndex < GPX_POINTS.length - 1) {
          const currentPoint = GPX_POINTS[position.pointIndex];
          const nextPoint = GPX_POINTS[position.pointIndex + 1];

          const lat =
            currentPoint[0] +
            (nextPoint[0] - currentPoint[0]) * position.progress;
          const lng =
            currentPoint[1] +
            (nextPoint[1] - currentPoint[1]) * position.progress;

          // GPS 오차 추가 (가우시안 분포)
          const errorLat = (Math.random() - 0.5) * 2 * (gpsErrorRange / 111000); // 위도 오차
          const errorLng =
            (Math.random() - 0.5) *
            2 *
            (gpsErrorRange / (111000 * Math.cos((lat * Math.PI) / 180))); // 경도 오차

          position.lat = lat + errorLat;
          position.lng = lng + errorLng;
          position.lastUpdate = Date.now();

          // 마커 위치 업데이트
          if (userMarkers[userId]) {
            userMarkers[userId].setLatLng([position.lat, position.lng]);
          }

          // 사용자 정보 업데이트
          const distance =
            ((position.pointIndex + position.progress) / GPX_POINTS.length) *
            2400; // 대략 2.4km
          const elapsedTime = Math.floor(
            (Date.now() - (currentPositions[userId].startTime || Date.now())) /
              1000
          );

          updateUserStatus(userId, "running", `${distance.toFixed(0)}m 진행`);
          updateLocationInfo(
            userId,
            position.lat,
            position.lng,
            distance,
            elapsedTime
          );
        }
      }

      // 위치 보정 API 호출
      async function sendLocationCorrection() {
        log("📡 위치 보정 API 호출 중...");

        const promises = TEST_USERS.map(async (user) => {
          const position = currentPositions[user.userId];
          if (!position) return;

          const gpsData = {
            userId: user.userId,
            eventId: EVENT_ID,
            eventDetailId: EVENT_DETAIL_ID,
            gpsData: [
              {
                lat: position.lat,
                lng: position.lng,
                altitude: 10.0,
                accuracy: 5.0,
                speed: 2.5,
                bearing: 180.0,
                timestamp: new Date().toISOString(),
              },
            ],
          };

          try {
            const response = await fetch(
              `${API_BASE}/api/gpx/correct-location`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(gpsData),
              }
            );

            log(
              `📥 ${user.name} 실시간 보정 응답: ${response.status} ${response.statusText}`
            );

            if (response.ok) {
              const result = await response.json();
              log(`✅ ${user.name} 위치 보정 완료`);

              // 체크포인트 도달 여부 확인
              if (
                result.checkpointReaches &&
                result.checkpointReaches.length > 0
              ) {
                result.checkpointReaches.forEach((cp) => {
                  log(
                    `🎯 ${user.name} - ${cp.checkpointId} 도달! (누적시간: ${cp.cumulativeTime}초)`
                  );
                });
              }
            } else {
              // 실시간 시뮬레이션에서도 실패 원인 상세 분석
              let errorDetails = `상태코드: ${response.status}`;

              try {
                const errorText = await response.text();
                if (errorText) {
                  errorDetails += `, 응답: ${errorText}`;
                }
              } catch (e) {
                errorDetails += `, 응답 읽기 실패: ${e.message}`;
              }

              log(`❌ ${user.name} 실시간 위치 보정 실패 - ${errorDetails}`);
              log(
                `📤 실패한 실시간 요청 데이터:\n${JSON.stringify(
                  gpsData,
                  null,
                  2
                )}`
              );
            }
          } catch (error) {
            log(`❌ ${user.name} 위치 보정 오류: ${error.message}`);
            log(
              `📤 오류 발생한 요청 데이터:\n${JSON.stringify(gpsData, null, 2)}`
            );
          }
        });

        await Promise.allSettled(promises);
      }

      // 리더보드 업데이트 (항상 로컬 기준으로도 갱신)
      function updateLeaderboard() {
        // 서버 API도 시도하지만, 항상 로컬 기준으로도 갱신
        fetch(`${API_BASE}/api/event-detail/${EVENT_ID}/${EVENT_DETAIL_ID}`)
          .then((response) => (response.ok ? response.json() : null))
          .then((eventDetail) => {
            if (
              eventDetail &&
              eventDetail.topRankers &&
              eventDetail.topRankers.length > 0
            ) {
              displayLeaderboard(eventDetail.topRankers);
            } else {
              displayLocalLeaderboard();
            }
          })
          .catch(() => {
            displayLocalLeaderboard();
          });
        // 항상 로컬 기준 리더보드도 갱신
        displayLocalLeaderboard();
      }

      // 리더보드 표시
      function displayLeaderboard(rankers) {
        const leaderboardEl = document.getElementById("leaderboard");

        if (rankers.length === 0) {
          displayLocalLeaderboard();
          return;
        }

        let html = "";
        rankers.forEach((ranker, index) => {
          const user = TEST_USERS.find(
            (u) => u.userId.toString() === ranker.userId
          );
          if (user) {
            html += `
                        <div class="d-flex justify-content-between align-items-center mb-2 p-2 bg-light rounded">
                            <div>
                                <span class="badge bg-primary me-2">${
                                  index + 1
                                }</span>
                                <strong>${ranker.name}</strong> (${
              ranker.bibNumber
            })
                            </div>
                            <div class="text-end">
                                <small class="text-muted d-block">${
                                  ranker.cumulativeTimeAtFarthestCp ||
                                  "00:00:00"
                                }</small>
                                <small class="text-muted">${
                                  ranker.cumulativeDistance
                                    ? ranker.cumulativeDistance.toFixed(0) + "m"
                                    : "0m"
                                }</small>
                            </div>
                        </div>
                    `;
          }
        });

        leaderboardEl.innerHTML =
          html || '<div class="text-center text-muted">순위 정보 없음</div>';
      }

      // 로컬 리더보드 표시
      function displayLocalLeaderboard() {
        const sortedUsers = TEST_USERS.map((user) => {
          const position = currentPositions[user.userId];
          if (!position) return { ...user, progress: 0 };

          return {
            ...user,
            progress:
              (position.pointIndex + position.progress) / GPX_POINTS.length,
          };
        }).sort((a, b) => b.progress - a.progress);

        let html = "";
        sortedUsers.forEach((user, index) => {
          const distance = user.progress * 2400; // 대략 2.4km
          html += `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2 bg-light rounded">
                        <div>
                            <span class="badge bg-primary me-2">${
                              index + 1
                            }</span>
                            <strong>${user.name}</strong> (${user.bibNumber})
                        </div>
                        <div class="text-end">
                            <small class="text-muted d-block">${(
                              user.progress * 100
                            ).toFixed(1)}%</small>
                            <small class="text-muted">${distance.toFixed(
                              0
                            )}m</small>
                        </div>
                    </div>
                `;
        });

        document.getElementById("leaderboard").innerHTML = html;
      }

      // 사용자 상태 업데이트
      function updateUserStatus(userId, status, stats) {
        const statusEl = document.getElementById(`status-${userId}`);
        const statsEl = document.getElementById(`stats-${userId}`);

        if (statusEl) {
          statusEl.className = `status-indicator status-${status}`;
        }

        if (statsEl) {
          statsEl.textContent = stats;
        }
      }

      // 위치 정보 업데이트
      function updateLocationInfo(userId, lat, lng, distance, elapsedTime) {
        const locationEl = document.getElementById(`location-${userId}`);
        if (locationEl) {
          const timeStr = `${Math.floor(elapsedTime / 60)}:${(elapsedTime % 60)
            .toString()
            .padStart(2, "0")}`;
          locationEl.textContent = `위치: ${lat.toFixed(6)}, ${lng.toFixed(
            6
          )} | ${distance.toFixed(0)}m | ${timeStr}`;
        }
      }

      // 시뮬레이션 일시정지
      function pauseSimulation() {
        if (!simulationRunning) return;

        clearInterval(simulationInterval);
        simulationRunning = false;

        TEST_USERS.forEach((user) => {
          updateUserStatus(user.userId, "paused", "일시정지");
        });

        log("⏸️ 시뮬레이션 일시정지");
      }

      // 시뮬레이션 정지
      function stopSimulation() {
        clearInterval(simulationInterval);
        simulationRunning = false;

        TEST_USERS.forEach((user) => {
          updateUserStatus(user.userId, "stopped", "정지됨");
        });

        log("⏹️ 실시간 시뮬레이션 정지");
      }

      // 배치 테스트 중지
      function stopBatchTest() {
        if (batchTestRunning) {
          batchTestRunning = false;

          TEST_USERS.forEach((user) => {
            updateUserStatus(user.userId, "stopped", "배치 테스트 중지됨");
          });

          log("⏹️ 배치 테스트 중지");
        }
      }

      // 시뮬레이션 리셋
      function resetSimulation() {
        stopSimulation();
        initUserMarkers();

        // 시작 시간 초기화
        TEST_USERS.forEach((user) => {
          if (currentPositions[user.userId]) {
            currentPositions[user.userId].startTime = Date.now();
          }
        });

        log("🔄 시뮬레이션 리셋 완료");
      }

      // 로그 출력
      function log(message) {
        const logArea = document.getElementById("logArea");
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement("div");

        // JSON 형태의 긴 메시지인 경우 스타일링 적용
        if (message.includes("{\n") || message.includes("[\n")) {
          logEntry.innerHTML = `<div style="margin-bottom: 5px;"><strong>[${timestamp}]</strong></div><pre style="background-color: #2d3748; color: #e2e8f0; padding: 8px; border-radius: 4px; font-size: 11px; overflow-x: auto; margin: 0;">${message}</pre>`;
        } else {
          logEntry.textContent = `[${timestamp}] ${message}`;
        }

        logArea.appendChild(logEntry);
        logArea.scrollTop = logArea.scrollHeight;

        console.log(`[GPS Simulation] ${message}`);
      }

      // ==== 새로운 Fake GPS 데이터 테스트 함수들 ====

      // Fake GPS 데이터 생성
      async function generateFakeGpsData() {
        log("📱 Fake GPS 데이터 생성 시작...");

        try {
          const response = await fetch(
            `${API_BASE}/api/gpx/generate-fake-gps-data?eventId=${EVENT_ID}&eventDetailId=${EVENT_DETAIL_ID}&intervalSeconds=10&errorRangeMeters=15`,
            {
              method: "GET",
            }
          );

          if (response.ok) {
            const data = await response.json();
            log(`✅ Fake GPS 데이터 생성 완료!`);
            log(`   - 총 유저: ${data.totalUsers}명`);
            log(`   - 경로 포인트: ${data.routeInfo.totalPoints}개`);
            log(`   - 예상 거리: ${data.routeInfo.estimatedDistance}`);

            // 유저별 데이터 정보 출력
            data.users.forEach((user, index) => {
              log(
                `   - ${user.name} (${user.bibNumber}): ${user.totalPoints}개 포인트, 예상 소요시간 ${user.estimatedDurationMinutes}분`
              );
            });

            // 각 유저별 gpsData를 1개(첫 번째 포인트)만 남기도록 가공해서 저장
            const singlePointData = {
              ...data,
              users: data.users.map((user) => ({
                ...user,
                gpsData:
                  user.gpsData && user.gpsData.length > 0
                    ? [user.gpsData[0]]
                    : [],
              })),
            };
            window.fakeGpsData = singlePointData;

            // 생성된 전체 데이터를 지도에 표시 (시각화는 전체 경로 사용)
            displayFakeGpsRoute(data);
          } else {
            log("❌ Fake GPS 데이터 생성 실패");
          }
        } catch (error) {
          log(`❌ Fake GPS 데이터 생성 오류: ${error.message}`);
        }
      }

      // 생성된 GPS 데이터를 지도에 표시
      function displayFakeGpsRoute(data) {
        // 기존 경로 제거
        if (window.fakeRouteLayer) {
          map.removeLayer(window.fakeRouteLayer);
        }

        // 각 유저의 경로를 다른 색으로 표시
        const colors = ["#ff4444", "#44ff44", "#4444ff", "#ffaa44", "#aa44ff"];
        window.fakeRouteLayer = L.layerGroup();

        data.users.forEach((user, index) => {
          const color = colors[index % colors.length];
          const gpsPoints = user.gpsData.map((point) => [point.lat, point.lng]);

          // 경로 라인 그리기
          const routeLine = L.polyline(gpsPoints, {
            color: color,
            weight: 2,
            opacity: 0.7,
            dashArray: "5, 5",
          }).bindPopup(
            `${user.name} (${user.bibNumber}) - ${user.totalPoints}개 포인트`
          );

          window.fakeRouteLayer.addLayer(routeLine);

          // 시작점 마커
          const startMarker = L.circleMarker(
            [gpsPoints[0][0], gpsPoints[0][1]],
            {
              color: color,
              fillColor: color,
              fillOpacity: 0.8,
              radius: 8,
            }
          ).bindPopup(`${user.name} - 시작점`);

          window.fakeRouteLayer.addLayer(startMarker);
        });

        window.fakeRouteLayer.addTo(map);
        log("🗺️ 생성된 GPS 경로를 지도에 표시했습니다.");
      }

      // 단일 유저 배치 테스트 (실시간 마커 업데이트 포함)
      async function batchTestSingleUser(userId) {
        if (simulationRunning) {
          log(
            "⚠️ 실시간 시뮬레이션이 실행 중입니다. 먼저 시뮬레이션을 정지해주세요."
          );
          return;
        }

        // 개별 테스트인 경우 상태 관리
        const isIndividualTest = !batchTestRunning;

        if (isIndividualTest) {
          batchTestRunning = true;
        }

        log(`🚀 유저 ${userId} 실시간 배치 테스트 시작...`);

        try {
          // 1. 먼저 fake GPS 데이터 생성 (아직 안 했다면)
          if (!window.fakeGpsData) {
            log("📱 Fake GPS 데이터 생성 중...");
            await generateFakeGpsData();
          }

          // 2. 해당 유저의 GPS 데이터 찾기
          const userGpsData = window.fakeGpsData.users.find(
            (u) => u.userId === userId
          );
          if (!userGpsData) {
            log(`❌ 유저 ${userId}의 GPS 데이터를 찾을 수 없습니다.`);
            return;
          }

          const gpsDataList = userGpsData.gpsData;
          const userName = userGpsData.name;

          log(
            `📍 ${userName} GPS 데이터 ${gpsDataList.length}개 포인트 순차 처리 시작`
          );

          // 3. 유저 상태 업데이트
          updateUserStatus(userId, "running", "배치 테스트 진행 중");

          // 4. 각 GPS 포인트를 순차적으로 처리
          let successCount = 0;
          let failCount = 0;

          for (let i = 0; i < gpsDataList.length; i++) {
            // 배치 테스트 중지 확인
            if (!batchTestRunning) {
              log(
                `⏹️ ${userName} 배치 테스트 중지됨 (진행률: ${(
                  (i / gpsDataList.length) *
                  100
                ).toFixed(1)}%)`
              );
              break;
            }

            const gpsPoint = gpsDataList[i];

            try {
              // 4-1. 마커 위치 업데이트
              if (userMarkers[userId]) {
                userMarkers[userId].setLatLng([gpsPoint.lat, gpsPoint.lng]);
              }

              // 4-2. 사용자 정보 업데이트
              const progressPercent = (
                ((i + 1) / gpsDataList.length) *
                100
              ).toFixed(1);
              const distance = gpsPoint.distanceFromStart || i * 50; // 대략적인 거리

              updateUserStatus(
                userId,
                "running",
                `${progressPercent}% 완료 (${distance}m)`
              );
              updateLocationInfo(
                userId,
                gpsPoint.lat,
                gpsPoint.lng,
                distance,
                i * 10
              );

              // 4-3. 서버 API 호출
              const gpsLocationData = {
                lat: gpsPoint.lat,
                lng: gpsPoint.lng,
                altitude: gpsPoint.altitude || 10.0,
                accuracy: gpsPoint.accuracy || 5.0,
                speed: gpsPoint.speed || 2.5,
                bearing: gpsPoint.bearing || 180.0,
                timestamp: gpsPoint.timestamp || new Date().toISOString(),
              };

              const requestDto = {
                userId: userId,
                eventId: EVENT_ID,
                eventDetailId: EVENT_DETAIL_ID,
                gpsData: [gpsLocationData],
              };

              // 4-3-1. 요청 데이터 로깅 (처음 몇 개만)
              if (i < 3) {
                log(
                  `📤 ${userName} 포인트 ${
                    i + 1
                  } 요청 데이터:\n${JSON.stringify(requestDto, null, 2)}`
                );
              }

              const response = await fetch(
                `${API_BASE}/api/gpx/correct-location`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify(requestDto),
                }
              );

              // 4-3-2. 응답 상태 코드와 헤더 확인
              log(
                `📥 ${userName} 포인트 ${i + 1} 응답: ${response.status} ${
                  response.statusText
                }`
              );

              if (response.ok) {
                const correctionResult = await response.json();
                successCount++;

                // 성공 결과 로깅 (처음 몇 개만)
                if (i < 3) {
                  log(
                    `✅ ${userName} 포인트 ${
                      i + 1
                    } 보정 결과:\n${JSON.stringify(correctionResult, null, 2)}`
                  );
                }

                // 4-4. 보정된 위치로 마커 업데이트 (옵션)
                if (
                  correctionResult.correctedLocations &&
                  correctionResult.correctedLocations.length > 0
                ) {
                  const corrected = correctionResult.correctedLocations[0];
                  if (userMarkers[userId]) {
                    userMarkers[userId].setLatLng([
                      corrected.correctedLatitude,
                      corrected.correctedLongitude,
                    ]);
                  }
                }

                // 체크포인트 도달 확인
                if (
                  correctionResult.checkpointReaches &&
                  correctionResult.checkpointReaches.length > 0
                ) {
                  correctionResult.checkpointReaches.forEach((cp) => {
                    log(
                      `🎯 ${userName} - ${cp.checkpointId} 도달! (누적시간: ${cp.cumulativeTime}초)`
                    );
                  });
                }
              } else {
                failCount++;

                // 실패 원인 상세 분석
                let errorDetails = `상태코드: ${response.status}`;

                try {
                  const errorText = await response.text();
                  if (errorText) {
                    errorDetails += `, 응답: ${errorText}`;
                  }
                } catch (e) {
                  errorDetails += `, 응답 읽기 실패: ${e.message}`;
                }

                log(
                  `❌ ${userName} 포인트 ${
                    i + 1
                  } 위치 보정 실패 - ${errorDetails}`
                );

                // 요청 데이터도 함께 로깅 (실패한 경우)
                log(
                  `📤 실패한 요청 데이터: ${JSON.stringify(
                    requestDto,
                    null,
                    2
                  )}`
                );
              }

              // 4-5. 진행률 로깅 (10% 단위)
              if ((i + 1) % Math.ceil(gpsDataList.length / 10) === 0) {
                log(
                  `📊 ${userName} 진행률: ${progressPercent}% (${i + 1}/${
                    gpsDataList.length
                  })`
                );
              }

              // 4-6. 처리 간격 대기 (마커 움직임을 볼 수 있도록)
              await new Promise((resolve) => setTimeout(resolve, 200)); // 200ms 대기
            } catch (error) {
              failCount++;
              log(`❌ ${userName} 포인트 ${i + 1} 처리 실패: ${error.message}`);
            }
          }

          // 5. 완료 처리
          updateUserStatus(userId, "stopped", "배치 테스트 완료");
          log(`✅ ${userName} 배치 테스트 완료!`);
          log(`   - 총 포인트: ${gpsDataList.length}개`);
          log(`   - 성공: ${successCount}개, 실패: ${failCount}개`);
          log(`   - 처리 시간: ${(gpsDataList.length * 0.2).toFixed(1)}초`);
        } catch (error) {
          log(`❌ 유저 ${userId} 배치 테스트 실패: ${error.message}`);
          updateUserStatus(userId, "stopped", "테스트 실패");
        } finally {
          // 개별 테스트인 경우에만 상태 해제
          if (isIndividualTest) {
            batchTestRunning = false;
          }
        }
      }

      // 전체 유저 배치 테스트 (실시간 마커 업데이트 포함)
      async function batchTestAllUsers() {
        if (simulationRunning) {
          log(
            "⚠️ 실시간 시뮬레이션이 실행 중입니다. 먼저 시뮬레이션을 정지해주세요."
          );
          return;
        }

        if (batchTestRunning) {
          log("⚠️ 배치 테스트가 이미 실행 중입니다.");
          return;
        }

        batchTestRunning = true;
        log(`🏃‍♂️ 전체 유저 실시간 배치 테스트 시작...`);

        try {
          // 먼저 fake GPS 데이터 생성
          if (!window.fakeGpsData) {
            log("📱 Fake GPS 데이터 생성 중...");
            await generateFakeGpsData();
          }

          const userIds = [1, 2, 3, 4, 5];

          // 동시 실행 옵션 (true: 동시, false: 순차)
          const simultaneousExecution = false;

          if (simultaneousExecution) {
            // 동시 실행 모드 - 모든 유저가 동시에 시작
            log("🚀 모든 유저 동시 실행 모드");

            const promises = userIds.map(async (userId, index) => {
              // 각 유저마다 약간의 지연을 두어 시차 시작
              await new Promise((resolve) => setTimeout(resolve, index * 1000));

              log(`📍 유저 ${userId} 동시 테스트 시작... (지연: ${index}초)`);

              try {
                await batchTestSingleUser(userId);
              } catch (error) {
                log(`❌ 유저 ${userId} 동시 테스트 실패: ${error.message}`);
              }
            });

            await Promise.allSettled(promises);
          } else {
            // 순차 실행 모드 - 한 명씩 완료 후 다음 유저
            log("🔄 순차 실행 모드");

            for (let i = 0; i < userIds.length; i++) {
              const userId = userIds[i];
              log(
                `📍 유저 ${userId} 순차 테스트 시작... (${i + 1}/${
                  userIds.length
                })`
              );

              try {
                await batchTestSingleUser(userId);

                // 각 유저 테스트 후 2초 대기
                if (i < userIds.length - 1) {
                  log(`⏳ 다음 유저 테스트까지 2초 대기...`);
                  await new Promise((resolve) => setTimeout(resolve, 2000));
                }
              } catch (error) {
                log(`❌ 유저 ${userId} 순차 테스트 실패: ${error.message}`);
              }
            }
          }

          log(`🎉 전체 유저 실시간 배치 테스트 완료!`);
          log(`📊 테스트 결과: ${userIds.length}명 처리 완료`);
        } catch (error) {
          log(`❌ 전체 유저 배치 테스트 실패: ${error.message}`);
        } finally {
          batchTestRunning = false;
        }
      }

      // ====== 주기적 Fake GPS 데이터 생성 및 전송 ======
      async function startPeriodicFakeGpsSend() {
        if (periodicFakeGpsInterval) {
          log("⚠️ 이미 주기적 전송이 실행 중입니다.");
          return;
        }
        log("⏱️ Fake GPS 데이터 생성 및 주기적 전송 시작...");
        try {
          const response = await fetch(
            "/api/v1/gpx/generate-fake-gps-data?eventId=1&eventDetailId=100",
            { method: "GET" }
          );
          if (!response.ok) {
            log("❌ Fake GPS 데이터 생성 실패");
            return;
          }
          periodicFakeGpsData = await response.json();
          log(
            `✅ Fake GPS 데이터 생성 결과:\n${JSON.stringify(
              periodicFakeGpsData,
              null,
              2
            )}`
          );

          periodicFakeGpsInterval = setInterval(async () => {
            if (!periodicFakeGpsData || !periodicFakeGpsData.users) {
              log("❌ 전송할 Fake GPS 데이터가 없습니다.");
              return;
            }
            for (const user of periodicFakeGpsData.users) {
              try {
                const requestBody = {
                  userId: user.userId,
                  eventId: 1,
                  eventDetailId: 100,
                  gpsData: user.gpsData,
                };
                log(
                  `📤 유저 ${
                    user.name
                  } correct-location 요청:\n${JSON.stringify(
                    requestBody,
                    null,
                    2
                  )}`
                );
                const postRes = await fetch("/api/v1/gpx/correct-location", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(requestBody),
                });
                const resultText = await postRes.text();
                log(
                  `📥 유저 ${user.name} correct-location 응답: ${postRes.status} ${postRes.statusText}\n${resultText}`
                );
              } catch (err) {
                log(
                  `❌ 유저 ${user.name} correct-location 전송 실패: ${err.message}`
                );
              }
            }
            log("⏱️ Fake GPS 데이터 1회 전송 완료");
          }, 60000);
        } catch (error) {
          log(`❌ Fake GPS 데이터 생성 오류: ${error.message}`);
        }
      }

      function stopPeriodicFakeGpsSend() {
        if (periodicFakeGpsInterval) {
          clearInterval(periodicFakeGpsInterval);
          periodicFakeGpsInterval = null;
          log("⏹️ Fake GPS 주기적 전송 중지");
        } else {
          log("⚠️ 주기적 전송이 실행 중이 아닙니다.");
        }
      }

      // 유틸리티 함수: 시간 포맷팅
      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (hours > 0) {
          return `${hours}:${minutes.toString().padStart(2, "0")}:${secs
            .toString()
            .padStart(2, "0")}`;
        } else {
          return `${minutes}:${secs.toString().padStart(2, "0")}`;
        }
      }

      // 유틸리티 함수: 거리 포맷팅
      function formatDistance(meters) {
        if (meters >= 1000) {
          return `${(meters / 1000).toFixed(2)}km`;
        } else {
          return `${meters.toFixed(0)}m`;
        }
      }

      // 대회 생성 API 호출
      async function createEvent() {
        log("🏆 대회 생성 시작...");
        try {
          const response = await fetch(
            `${API_BASE}/api/gpx/create-test-event?eventId=${EVENT_ID}&eventName=TestMarathon`,
            {
              method: "POST",
            }
          );
          if (response.ok) {
            log("✅ 대회 생성 완료");
          } else {
            log("❌ 대회 생성 실패");
          }
        } catch (error) {
          log(`❌ 대회 생성 오류: ${error.message}`);
        }
      }

      // 코스 생성 API 호출
      async function createCourse() {
        log("🛤️ 코스 생성 시작...");
        try {
          const response = await fetch(
            `${API_BASE}/api/gpx/create-test-course?eventId=${EVENT_ID}&eventDetailId=${EVENT_DETAIL_ID}&courseName=TestCourse`,
            {
              method: "POST",
            }
          );
          if (response.ok) {
            log("✅ 코스 생성 완료");
          } else {
            log("❌ 코스 생성 실패");
          }
        } catch (error) {
          log(`❌ 코스 생성 오류: ${error.message}`);
        }
      }

      // 유저 생성 API 호출
      async function createUsers() {
        log("👥 유저 생성 시작...");
        try {
          const response = await fetch(
            `${API_BASE}/api/gpx/create-test-users?eventId=${EVENT_ID}&eventDetailId=${EVENT_DETAIL_ID}`,
            {
              method: "POST",
            }
          );
          if (response.ok) {
            const usersData = await response.json();
            log("✅ 테스트 유저 5명 생성 완료");
            log(
              `   생성된 유저: ${usersData.users.map((u) => u.name).join(", ")}`
            );
          } else {
            log("❌ 테스트 유저 생성 실패");
          }
        } catch (error) {
          log(`❌ 유저 생성 오류: ${error.message}`);
        }
      }

      // 상태 확인 API 호출
      async function checkStatus() {
        log("📊 상태 확인 시작...");
        try {
          const response = await fetch(
            `${API_BASE}/api/event-detail/${EVENT_ID}/${EVENT_DETAIL_ID}`
          );
          if (response.ok) {
            const eventDetail = await response.json();
            log(`✅ 상태 확인 완료: ${JSON.stringify(eventDetail)}`);
          } else {
            log("❌ 상태 확인 실패");
          }
        } catch (error) {
          log(`❌ 상태 확인 오류: ${error.message}`);
        }
      }
    </script>
  </body>
</html>
